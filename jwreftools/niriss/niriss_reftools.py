"""
This module contains functions to create NIRISS reference files.


Grism
-----
### February 28, 2017

* Throughput curves generated using the "current" ETC configuration files
found at `/grp/jwst/wit/niriss/ETC/CURRENT/`. These include the following
components:

        - Telescope OTE (primary area = 254009.0 cm^2 , from pandeia/ETC)
        - Internal instrument optics
        - Blocking filter passband
        - Disperser passband (`p1=A`, `p2=C`, `p3=D` and `m1=E` orders/"beams").
        - Detector QE and quantum yield

        Through there are separate ETC files, these are currently the same for
        both the GR150C and GR150R dispersing elements.  (**NB:** higher orders
        are visible in the CV3 test data but are not currently included in the
        configuration files.)

* The ETC doesn't have a 0th order throughput file (`beam=B`), so for now is
  taken to be the original file generated by V. Dixon for the "WFSS cookbook".

* The trace configuration has been updated by G. Brammer from the original
  cookbook files based on the CV trace and wavelength calibration data.

        - Separate traces for the two dispersers GR150R (column) and GR150C (row)
dispersing elements.

        - It is now assumed that the traces for all orders and filters are
        described by a common polynomial function, though with a 0th order
        offset for the different blocking filters.  This simplifies the
        analysis and is also fully consistent with the CV3 data.

        - **The configuration files are generated in the old aXe convention
        with increasing wavelength of the p1st order spectra increasing towards
         `+x` detector pixels**.  This corresponds to CCW rotations of the
          DMS-format images of 90 (GR150R) and 180 (GR150C) degrees.

        - The traces are defined relative to a reference position of the
         filter wheel specified in the `FWCPOS_REF` parameter (in degrees).
           For a given science observation, the trace polynomials must be
            rotated by an angle `FWCPOS - FWCPOS_REF`.  This rotation has an
             analytic solution for linear and quadratic traces.

        - Spatial variation of the trace polynomials was determined from 5
         separate locations on the detector.

"""
import re
import numpy as np
from asdf import AsdfFile
from astropy.modeling import models
from astropy.modeling.models import Mapping, Identity
from astropy.io import fits
from astropy import units as u

def create_trace_forward_old(outname):
    """
    Make a reference file which contains the polynomial models
    for the NIRISS grism trace


    Parameters
    ----------
    outname : str
        The name of the output reference file
    """

    f = AsdfFile()
    f.tree = {'model': model}
    f.write_to(outname)


def create_grism_config(conffile="",
                        grism="Unspecified",
                        detector="NRS",
                        history_comment="NIRISS Grism Reference File",
                        author="spacetelescope",
                        opgsname="",
                        history="",
                        outname=""):
    """
    Create an asdf reference file to hold Grism C (column) or Grism R (rows)
    configuration, no sensativity information is included

    Note: The orders are named alphabetically, i.e. Order A, Order B
    There are also sensativity fits files which are tables of wavelength,
    sensativity, and error. These are specified in the conffile but will
    not be read in and saved in the output reference file.

    direct_filter is not specified because it assumes that the wedge
    information (wx,wy) is included in the conf file in one of the key-value
    pairs, where the key includes the beam designation

    For each spectral order, the configuration file contains a pair of
    magnitude-cutoff values. Sources with magnitudes fainter than the
    extraction cutoff (MMAG_EXTRACT_X) are not extracted, but are accounted
    for when computing the spectral contamination and background estimates.
    Sources with magnitudes fainter than the second cutoff (MMAG_MARK_X) are
    completely ignored.  Here, X equals A, B, C, etc., with each letter
    referring to a spectral order, as specified in the configuration file.
     -- the initial conf file that nor gave me didn't have this keyword so
     this code adds a placeholder.

     this reference file also contains the polynomial model which is appropriate
     for the coefficients which are listed.

    Parameters
    ----------
    conffile : str
        The text file with configuration information
    grism : str
        Name of the grism the conffile corresponds to
    aperture : str
        Name of the aperture/subarray. (e.g. GRISM_F322W2)
    opgsname : str
        Unknown
    author : str
        The name of the author
    history : str
        A comment about the refrence file to be saved with the meta information
    outname : str
        Output name for the reference file


    Examples
    --------


    Returns
    -------
    fasdf : asdf.AsdfFile

    """
    tree = {"TITLE": "NIRISS Grism Configuration",
            "TELESCOP": "JWST",
            "INSTRUMENT": "NIRISS",
            "PEDIGREE": "GROUND",
            "REFTYPE": "specwcs",
            "AUTHOR": author,
            "DETECTOR": detector,
            "DESCRIP": "{0:s} Configuration".format(grism),
            "EXP_TYPE": "NRS_WFSS",
            "USEAFTER": "2014-01-01T00:00:00",
            "WAVELENGTH_UNITS": u.micron,
            "MODEL_TYPE": 'NIRISSGrismModel',
            }

    # get all the key-value pairs from the input file
    conf = dict_from_file(conffile)
    beamdict = split_order_info(conf)
    letter = re.compile('^[a-zA-Z0-9]{0,1}$')  # match one only
    etoken = re.compile("^BEAM_[A-Z,a-z]{1,1}")  # find beam key

    # add min and max mag info if not provided
    # also make beam coeff lists
    # wx are the wedge offsets for the filters
    # in niriss there's a different grism file for each filter

    for k, bdict in beamdict.items():
        if isinstance(bdict, dict):
            keys = bdict.keys()
            # minmag = "MMAG_EXTRACT"
            maxmag = "MMAG_MARK"
            #if minmag not in keys:
            #    beamdict[k][minmag] = 0.0
            if maxmag not in keys:
                beamdict[k][maxmag] = 0.0
            #if "wx" not in keys:
            #    beamdict[k]['wx'] = 0.0
            #if "wy" not in keys:
            #    beamdict[k]['wy'] = 0.0

    # add to the big tree
    # tree['spectral_orders'] = beamdict


    # add the polynomial model for this file.
    # this structure allows there to be a different polynomial relationship
    # for each order if necessary. Either way, the coefficients should be
    # stored with the polynomials since they are directly dependent on
    # each other
    # for order in tree['spectral_orders']:
    #     print("order: {}".format(order))
    #     xc = tree['spectral_orders'][order]["DISPX"]
    #     yc = tree['spectral_orders'][order]["DISPY"]
    #     lc = tree['spectral_orders'][order]["DISPL"]
    #     print("{} {} {}".format(xc, yc, lc))
    #     model = models.PolyTraceDispersion(xc, yc, lc, w)
    #     tree['spectral_orders'][order]['model'] = model

    # Filter wavelength ranges from gabe in microns
    # F090W 0.79 1.03
    # F115W 0.97 1.32
    # F140M 1.29 1.52
    # F150W 1.29 1.71
    # F158M 1.41 1.74
    # F200W 1.70 2.28
    filters = {'F090W': [0.79, 1.03],
               'F115W': [0.97, 1.32],
               'F140M': [1.29, 1.52],
               'F150W': [1.29, 1.71],
               'F158M': [1.41, 1.74],
               'F200W': [1.70, 2.28]
               }
    # this depends on the filter name being part of the filename for the
    # input conffile
    fkeys = filters.keys()
    for key in fkeys:
        if key in conffile:
            wrange = filters[key]
            break

    # The lists below need
    # to remain ordered and referenced by filter or order
    orders = sorted(beamdict.keys())

    # disp[] per sorted order
    displ = []
    dispx = []
    dispy = []
    for order in orders:
        # convert the displ wavelengths to microns
        print(beamdict[order]['DISPL'])
        l1 = beamdict[order]['DISPL'][0] / 10000.
        l2 = beamdict[order]['DISPL'][1] / 10000.
        displ.append((l1,l2))
        dispx.append(beamdict[order]['DISPX'])
        dispy.append(beamdict[order]['DISPY'])

    tree['orders'] = orders
    tree['lcoeff'] = displ
    tree['xcoeff'] = dispx
    tree['ycoeff'] = dispy
    tree['wrange'] = wrange

    # we need to add the FWCPOS_REF value back in
    tree['FWCPOS_REF'] = conf['FWCPOS_REF']

    fasdf = AsdfFile()
    sdict = {'name': 'nircam_reftools.py',
             'author': author,
             'homepage': 'https://github.com/spacetelescope/jwreftools',
             'version': '0.7'}

    fasdf.add_history_entry(history, software=sdict)
    fasdf.tree = tree

    fasdf.write_to(outname)


def read_sensitivity_file(filename):
    """Read the sensativity fits file.

    This is assumed to be an MEF file with a table in the first extension

    Parameters
    ----------
    filename : str
        The name of the fits file

    Returns
    -------
    A dictionary of lists where the keys are the column names
    """
    if not isinstance(filename, str):
        raise ValueError("Expected the name of the sensitivity fits file")

    sens = dict()
    with fits.open(filename) as fh:
        columns = fh[1].header['TTYPE*']
        for c in columns.values():
            sens[c] = fh[1].data.field(c)
            if "WAVE" in c:
                sens["WRANGE"] = [np.min(sens[c]), np.max(sens[c])]
    return sens

def split_order_info(keydict):
    """Accumulate keys just for each Beam/order.

    Designed to take as input the dictionary created by dict_from_file
    split out and accumulate the keys for each beam/order.
    The keys must have the beam in their string, the spurious beam designation
    is removed from the returned dictionary. Keywords with the same first name
    in the underscore separated string followed by a number are assumed to be
    ranges


    Parameters
    ----------
    keydict : dictionary
        Dictionary of key value pairs

    Returns
    -------
    dictionary of beams, where each beam has a dictionary of key-value pairs
    Any key pairs which are not associated with a beam get a separate entry
    """

    if not isinstance(keydict, dict):
        raise ValueError("Expected an input dictionary")

    # has beam name fits token
    # token = re.compile('^[a-zA-Z]*_(?:[+\-]){0,1}[a-zA-Z0-9]{1}_{1}')
    token = re.compile('^[a-zA-Z]*_[a-zA-Z0-9]{1}_(?:\w)')
    rangekey = re.compile('^[a-zA-Z]*_[0-1]{1,1}$')
    rdict = dict()  # return dictionary
    beams = list()
    savekey = dict()

    # prefetch number of Beams, beam is the second string
    for key in keydict:
        if token.match(key):
            b = key.split("_")[1].upper()
            if b not in beams:
                beams.append(b)
                rdict[b] = dict()
            newkey = key.replace("_{}".format(b), "")
            rdict[b][newkey] = keydict[key]

    # look for range variables to make them into tuples
    for b, d in rdict.items():
        if isinstance(d, dict):
            keys = d.keys()
        else:
            keys = []
        rkeys = []
        odict = {}
        for k in keys:
            if rangekey.match(k):
                rkeys.append(k)
        for k in rkeys:
            mlist = [m for m in rkeys if k.split("_")[0] in m]
            root = mlist[0].split("_")[0]
            if root not in odict:
                for mk in mlist:
                    if eval(mk[-1]) == 0:
                        zero = d[mk]
                    elif eval(mk[-1]) == 1:
                        one = d[mk]
                    else:
                        raise ValueError("Unexpected range variable {}"
                                         .format(mk))
                odict[root] = (zero, one)
        # combine the dictionaries and remove the old keys
        if odict:
            d.update(odict)
        if rkeys:
            for k in rkeys:
                del d[k]

    return rdict



def dict_from_file(filename):
    """Read in a file and return a named tuple of the key value pairs.

    This is a generic read for a text file with the line following format:

    keyword<token>value

    Where keyword should start with a character, not a number
    Non-alphabetic starting characters are ignored
    <token> can be space or comma

    Parameters
    ----------
    filename : str
        Name of the file to interpret

    Examples
    --------
    dict_from_file('NIRISS_C.conf')

    Returns
    -------
    dictionary of deciphered keys and values

    """
    token = '\s+|(?<!\d)[,](?!\d)'
    letters = re.compile("(^[a-zA-Z])")  # starts with a letter
    numbers = re.compile("(^(?:[+\-])?(?:\d*)(?:\.)?(?:\d*)?(?:[eE][+\-]?\d*$)?)")
    empty = re.compile("(^\s*$)")  # is a blank line

    print("\nReading {0:s}  ...".format(filename))
    with open(filename, 'r') as fh:
        lines = fh.readlines()
    content = dict()
    for line in lines:
        value = None
        vallist = []
        key = None
        if not empty.match(line):
            if letters.match(line):
                pair = re.split(token, line.strip(), maxsplit=10)
                if len(pair) == 2:
                    key = pair[0]
                    if numbers.fullmatch(pair[1]):
                        value = eval(pair[1])
                else:  # more than 2 values
                    key = pair[0]
                    vals = pair[1:]
                    for v in vals:
                        if numbers.fullmatch(v):
                            vallist.append(eval(v))
                        else:
                            raise ValueError("Unexpected value for {0}"
                                             .format(key))

        if key:
            if (("FILTER" not in key) and ("SENS" not in key)):
                if (value is None):
                    content[key] = vallist
                    print("Setting {0:s} = {1}".format(key, vallist))
                else:
                    content[key] = value
                    print("Setting {0:s} = {1}".format(key, value))
    return content
